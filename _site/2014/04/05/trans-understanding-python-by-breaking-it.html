<!DOCTYPE html><html lang="en"><head><title>Understanding Python by breaking it — 8D is Here</title><link rel="prev" href="http://blog.xiaoba.me"><link rel="stylesheet" href="/css/site.css"><meta name="viewport" content="width=device-width"><meta name="author" content="Yuwei Ba"><meta name="keywords" content="Javascript, Python, Life, Thoughts"><meta name="description" content="Programming makes life easier and better. Life Lover."><link rel="icon" href="/favicon.png" type="image/png"><link rel="canonical" href="http://blog.xiaoba.me/2014/04/05/trans-understanding-python-by-breaking-it.html"><meta property="twitter:card" content="summary"><meta property="twitter:site" content="@ibigbug"><meta property="twitter:creator" content="@ibigbug"><meta property="twitter:title" content="Understanding Python by breaking it — 8D is Here"><meta property="twitter:description" content=" Programming makes life easier and better. Life Lover. "><meta property="twitter:url" content="http://blog.xiaoba.me/2014/04/05/trans-understanding-python-by-breaking-it.html"><meta property="twitter:domain" content="8D is Here">
<script>
 (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
 (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
 m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
 })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
 ga('create', 'UA-53224060-1', 'auto');
 ga('send', 'pageview');
</script>
</head><body class="yue"><div class="header"><div class="inner-header"><div class="nav">



<a class="page-link" href="/">Home</a>

<a class="page-link" href="/archives/">Archives</a>

<a class="page-link" href="/thoughts/">Thoughts</a>

<a class="page-link" href="/about/">Résumé</a>

<a class="page-link" href="/feed.xml">Feed</a>
</div></div><div class="inner-header-iphone"><div class="nav"><?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="图形" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="32px" height="32px" viewBox="0 0 1000 1024" enable-background="new 15.167 -16.333 1000 1024" xml:space="preserve"><path fill="#272636" d="M872 675q28 0 47.5 -19.5t19.5 -47.5v-51q0 -28 -19.5 -47.5t-47.5 -19.5h-742q-28 0 -47.5 19.5t-19.5 47.5v51q0 28 19.5 47.5t47.5 19.5h742zM872 362q28 0 47.5 -19.5t19.5 -47.5v-51q0 -28 -19.5 -47.5t-47.5 -19.5h-742q-28 0 -47.5 19.5t-19.5 47.5v51 q0 28 19.5 47.5t47.5 19.5h742zM872 49q28 0 47.5 -19.5t19.5 -47.5v-51q0 -28 -19.5 -47.5t-47.5 -19.5h-742q-28 0 -47.5 19.5t-19.5 47.5v51q0 28 19.5 47.5t47.5 19.5h742z" transform="translate(0, 800) scale(1, -1)"/></svg><ul class="nav-list">



<li><a href="/" class="page-link">Home</a></li>

<li><a href="/archives/" class="page-link">Archives</a></li>

<li><a href="/thoughts/" class="page-link">Thoughts</a></li>

<li><a href="/about/" class="page-link">Résumé</a></li>

<li><a href="/feed.xml" class="page-link">Feed</a></li>
</ul></div></div></div><div class="main-wrapper"><div class="inner-wrapper"><div class="logo"><a href="/">8D is Here</a></div><div class="page-meta">
天青色等烟雨，而我在等你。
</div><div class="main-area"><div class="post-entry"><h1 class="entry-title">Understanding Python by breaking it</h1><div class="entry-meta"><time class="updated">Apr 5, 2014</time></div><div class="entry-content"><blockquote>
  <p>这篇文章是从Python Weekly里面看到的，刚好最近在学C。记录分享一下。<a href="http://blog.hakril.net/articles/0-understanding-python-by-breaking-it.html?utm_term=0_9e26887fc5-42441d6a58-312705645">点击这里查看原文</a></p>
</blockquote>

<p>【译文开始】</p>

<p>我最近发现了<code class="highlighter-rouge">ctype</code>，打算通过它来用一种不应该的方式操作Python。目的就是直接从Python解释器来了解<em>Python内部</em>是如何工作的。  这篇文章研究的是CPython在Python2.7下的实现。</p>

<p>#引用计数和垃圾回收</p>

<p>关于Python首先要知道的是它的垃圾回收机制是采用引用计数的方式。也就是说，每一个Python对象都有一个<em>ref counter</em>来记录有多少个引用指向这个对象。   我们首个目标是在Python解释器里面把任何一个对象的<em>ref counter</em>暴露出来。</p>

<p>我们将要用的重要工具是：</p>

<ul>
  <li><code class="highlighter-rouge">ctypes._CData.from_address</code>，通过他我们可以在任何地址创建一个ctypes的映射：例如（一个不好的例子）</li>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">ctypes</span>
<span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="c"># segfault! ( to dereference 0 is not a good idea)</span></code></pre></figure>

<p>现在我们可以从我们的地址空间里面任意地取值了。下一步是取一个对象的地址。为此，我们需要用到一个内置的方法：</p>

<ul>
  <li><code class="highlighter-rouge">id()</code>: 返回一个对象的「标识」。在这个对象的生命周期内，这是一个保证唯一确定的integer（或者 long integer）。    CPython 实现细节：这实际就是对象在内存中的地址。</li>
</ul>

<p>我们现在要做的是取到一个Python对象的<em>ref counter</em>的偏移地址：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/** My own comments begin by '**' **/</span>
<span class="cm">/** From: Includes/object.h **/</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_object</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
<span class="p">}</span> <span class="n">PyObject</span><span class="p">;</span>

<span class="cm">/* PyObject_HEAD defines the initial segment of every PyObject. */</span>
<span class="cp">#define PyObject_HEAD    \
    _PyObject_HEAD_EXTRA   </span><span class="cm">/** empty in standard build **/</span><span class="cp"> \
    Py_ssize_t ob_refcnt;  </span><span class="cm">/**ref counter **/</span><span class="cp"> \
    struct _typeobject *ob_type; </span><span class="cm">/** pointer to the type **/</span></code></pre></figure>

<p>从上面我们可以看到 <code class="highlighter-rouge">ob_refcnt</code> 是结构体的第一个成员，因此 addr(ob_refcnt) == addr(object) == id(object)</p>

<p>所以我们可以轻松的写出函数：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">get_ref</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="s">""" returns a c_size_t, which is the refcount of obj """</span>
    <span class="k">return</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span></code></pre></figure>

<p>来试一下！</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">ctypes</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">get_ref</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="o">...</span>     <span class="s">""" returns a c_size_t, which is the refcount of obj """</span>
<span class="o">...</span>     <span class="k">return</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
<span class="o">...</span>
<span class="c"># the c_ulong is not a copy of the address</span>
<span class="c"># so any modification of the ob_refcnt are directly visible</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l_ref</span> <span class="o">=</span> <span class="n">get_ref</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l_ref</span> 
<span class="n">c_ulong</span><span class="p">(</span><span class="il">1L</span><span class="p">)</span> <span class="c"># there is just one reference on the list (l)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">l</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l_ref</span> 
<span class="n">c_ulong</span><span class="p">(</span><span class="il">2L</span><span class="p">)</span><span class="c"># two references on the list (l and l2)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">del</span> <span class="n">l</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l_ref</span>
<span class="n">c_ulong</span><span class="p">(</span><span class="il">1L</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">del</span> <span class="n">l2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l_ref</span>
<span class="n">c_ulong</span><span class="p">(</span><span class="il">0L</span><span class="p">)</span> <span class="c"># no more reference!</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">another_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l_ref</span>
<span class="n">c_ulong</span><span class="p">(</span><span class="il">1L</span><span class="p">)</span> <span class="c"># woot : old list's ob_refcnt have changed</span></code></pre></figure>

<p>这个例子非常的直白，不过最后两行需要解释一下。为什么创建一个新的list会改变原有list的<em>ref counting</em>？  这是垃圾回收干的！当<code class="highlighter-rouge">old_list</code>的<em>ref count</em>变为0的时候，GC 「清理」这个list，然后把它送进一个unused list的池，当下次创建list的时候，就会被重新使用。</p>

<p>证明：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">l1</span><span class="p">))</span>
<span class="s">'0xa367e8'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">l2</span><span class="p">))</span>
<span class="s">'0xa36d40'</span>  <span class="c"># not the same address as l1 (hopefully)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">del</span> <span class="n">l1</span>  <span class="c"># l1 is garbage collected</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">l3</span><span class="p">))</span>
<span class="s">'0xa367e8'</span>  <span class="c"># l1 address is reused for the new list</span></code></pre></figure>

<p>#特例： <code class="highlighter-rouge">int</code> 和 <code class="highlighter-rouge">str</code></p>

<p>在CPython的int实现中，从[-5； 256]这个区间的的引用是共享的。我们有办法来验证！</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># with "non-shared" int</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">257</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">257</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_ref</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
<span class="n">c_ulong</span><span class="p">(</span><span class="il">1L</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_ref</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
<span class="n">c_ulong</span><span class="p">(</span><span class="il">1L</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
<span class="bp">False</span>  <span class="c"># logic : differents objects</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">x3</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_ref</span><span class="p">(</span><span class="n">x3</span><span class="p">)</span>
<span class="n">c_ulong</span><span class="p">(</span><span class="il">409L</span><span class="p">)</span> <span class="c">#  all ref to "0" point the the same "int(0)" object</span></code></pre></figure>

<p>对于字符串也是一样！</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="s">"python"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_ref</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="n">c_ulong</span><span class="p">(</span><span class="il">8L</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="s">"python"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_ref</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
<span class="n">c_ulong</span><span class="p">(</span><span class="il">9L</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
<span class="bp">True</span>  <span class="c"># the two variables are references to the same string object!</span></code></pre></figure>

<h1 id="破坏引用计数">破坏引用计数</h1>

<p>到目前为止，我们还知识读取<code class="highlighter-rouge">ob_refcnt</code>的值。如果我们改变它会怎么样？   我们可以改写<code class="highlighter-rouge">ob_refcnt</code>强制提前进行垃圾回收！</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_ref</span> <span class="o">=</span> <span class="n">get_ref</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">xx</span> <span class="o">=</span> <span class="n">x</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_ref</span>
<span class="n">c_ulong</span><span class="p">(</span><span class="il">2L</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x_ref</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># GC now thinks that we have just one reference to the list</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">del</span> <span class="n">xx</span> <span class="c"># ob_refcnt == 0 -&gt; garbage collection!</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="p">[]</span> <span class="c"># garbage collection of a list sets its size to 0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">another_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span> <span class="p">,</span><span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">42</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span> <span class="p">,</span><span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">42</span><span class="p">]</span>  <span class="c"># always the same "reuse list" tricks!</span></code></pre></figure>

<p>当然：这种写法会使解释器进入不稳定的状态并且很可能导致崩溃！</p>

<h1 id="干扰-tuple">干扰 <code class="highlighter-rouge">tuple</code></h1>

<p>干扰<code class="highlighter-rouge">tuple</code>是很有意思并且比较容易的事情。文档里面讲「<code class="highlighter-rouge">tuple</code>是一类不可变的序列」：我们来试着改变它！</p>

<p>如果你查看CPython的实现你会发现：</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/** From: Includes/tupleobject.h **/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">ob_item</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/** An array of pointer to PyObject **/</span>
<span class="p">}</span> <span class="n">PyTupleObject</span><span class="p">;</span>

<span class="cm">/** From: Includes/object.h **/</span>
<span class="cp">#define PyObject_VAR_HEAD     \
    PyObject_HEAD    </span><span class="cm">/** See: part 1 **/</span><span class="cp"> \
    Py_ssize_t ob_size; </span><span class="cm">/* Number of items in variable part */</span></code></pre></figure>

<p>所以对于元组，比较重要的两点是：</p>

<ul>
  <li>元组本质上就是指向<code class="highlighter-rouge">PyObject</code>的指针组成的数组并且，</li>
  <li>元组由三个<code class="highlighter-rouge">size_t</code>(ref_count, ob_type, ob_size)和刚刚提到的指针数组构成。</li>
</ul>

<p>基于<code class="highlighter-rouge">ctype</code>中的<code class="highlighter-rouge">memmove</code>实现，我们可以构造一个<code class="highlighter-rouge">tuplecopy</code>函数：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">tuplecpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">begin_offset</span><span class="p">):</span>
    <span class="s">"""
       Of course this function should NEVER be used in real code
       It  will probably result in segfaults/crashes
       - copy tuple(src) to dst[begin_offset:] tuple
       - remember id(x) -&gt; addressof(x)
    """</span>
    <span class="n">OFFSET</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
    <span class="n">PTR_SIZE</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">)</span>
    <span class="n">dst_addr</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="o">+</span> <span class="n">OFFSET</span> <span class="o">+</span> <span class="n">PTR_SIZE</span> <span class="o">*</span> <span class="n">begin_offset</span>
    <span class="n">src_addr</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="o">+</span> <span class="n">OFFSET</span>
    <span class="n">ctypes</span><span class="o">.</span><span class="n">memmove</span><span class="p">(</span><span class="n">dst_addr</span><span class="p">,</span> <span class="n">src_addr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="o">*</span> <span class="n">PTR_SIZE</span><span class="p">)</span></code></pre></figure>

<p>我们来试下新玩具！</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">x1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s">"A"</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s">"B"</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="p">(</span><span class="s">"BEFORE -&gt; x1 = {0} | x2  = {1}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tuplecpy</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="p">(</span><span class="s">"AFTER  -&gt; x1 = {0} | x2  = {1}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>

<span class="c">#Result:</span>
<span class="c">#    BEFORE -&gt; x1 = ('A', 'A', 'A', 'A') | x2  = ('B', 'B')</span>
<span class="c">#    AFTER  -&gt; x1 = ('A', 'A', 'B', 'B') | x2  = ('B', 'B')</span></code></pre></figure>

<p>It works! 但是为什么说这种写法本质上是不好的（抛开修改元组来说）？   答案在第一部分中：我们创建了很多对象的引用（在<code class="highlighter-rouge">src</code> tuple 中的那些）却没有增加他们的<em>ref count</em></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">x1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s">"B"</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x2</span> <span class="o">=</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],)</span>

<span class="c"># problem is : </span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">get_ref</span><span class="p">(</span><span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span>
<span class="n">c_ulong</span><span class="p">(</span><span class="il">1L</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">del</span> <span class="n">x2</span> <span class="c"># no more references</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x1</span>
<span class="p">(</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">refcnt</span> <span class="mi">0</span> <span class="n">at</span> <span class="mh">0xacac68</span><span class="o">&gt;</span><span class="p">)</span>  <span class="c"># nice printing of an object with ob_refcnt == 0 :)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">69</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x1</span> <span class="c"># GC IN ACTION \o/</span>
<span class="p">(</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">69</span><span class="p">])</span> <span class="c"># Same principle as before</span></code></pre></figure>

<p>我们可以修改一下函数让它增加引用计数（但这并不意味着你可以在实际编码中这么使用。。）</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">tuplecpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">begin_offset</span><span class="p">):</span>
    <span class="s">"""
       Of course this function should NEVER be used in real code
       It  will probably result in segfaults/crashes
       - copy tuple(src) to dst[begin_offset:] tuple
       - remember id(x) -&gt; addressof(x)
    """</span>
    <span class="n">OFFSET</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
    <span class="n">PTR_SIZE</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_size_t</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">get_ref</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span> <span class="c"># manually update ob_refcnt</span>
    <span class="n">dst_addr</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="o">+</span> <span class="n">OFFSET</span> <span class="o">+</span> <span class="n">PTR_SIZE</span> <span class="o">*</span> <span class="n">begin_offset</span>
    <span class="n">src_addr</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="o">+</span> <span class="n">OFFSET</span>
    <span class="n">ctypes</span><span class="o">.</span><span class="n">memmove</span><span class="p">(</span><span class="n">dst_addr</span><span class="p">,</span> <span class="n">src_addr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="o">*</span> <span class="n">PTR_SIZE</span><span class="p">)</span></code></pre></figure>

<h1 id="深入函数和编码对象">深入函数和编码对象</h1>

<p>现在我们可以修改元组了，我们来看下修改函数和编码对象中的一些重要元组有什么影响</p>

<h2 id="编码对象code-object">编码对象（Code object）</h2>

<p>文档中是这样解释的：「Code objects 表示的是编译成的可执行的 Python 代码」  在Python 2中，编码对象存在一个函数的<code class="highlighter-rouge">func_code</code>变量中。</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">dis</span>  <span class="c"># bytecode disassembler module</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">time_2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
<span class="o">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">time_2</span><span class="o">.</span><span class="n">func_code</span>
<span class="o">&lt;</span><span class="n">code</span> <span class="nb">object</span> <span class="n">time_2</span> <span class="n">at</span> <span class="mh">0x9ee230</span><span class="p">,</span> <span class="nb">file</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">time_2</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="mi">8</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">time_2</span><span class="p">)</span>
          <span class="mi">0</span> <span class="n">LOAD_CONST</span>               <span class="mi">1</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
          <span class="mi">3</span> <span class="n">LOAD_FAST</span>                <span class="mi">0</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
          <span class="mi">6</span> <span class="n">BINARY_MULTIPLY</span>
          <span class="mi">7</span> <span class="n">RETURN_VALUE</span></code></pre></figure>

<p>如果我们查看那个函数（很简单的一个函数）的反编译结果，我们会发现这个函数：</p>

<ul>
  <li>载入常量 (2)，</li>
  <li>载入变量 (x)，</li>
  <li>讲两个值相乘，</li>
  <li>返回结果</li>
</ul>

<p>如果我们仔细观察下第一步（LOAD_CONST）我们会发现下面的结果：</p>

<ul>
  <li>LOAD_CONST 被调用的时候，传入了参数1</li>
  <li>这个参数指向的是常数 2</li>
</ul>

<p>事实上，1 就是编码对象拥有的常量tuple的一个偏移。</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">time_2</span><span class="o">.</span><span class="n">func_code</span><span class="o">.</span><span class="n">co_consts</span>  <span class="c"># tuple of constants of our code object</span>
<span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">time_2</span><span class="o">.</span><span class="n">func_code</span><span class="o">.</span><span class="n">co_consts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">2</span> <span class="c"># yep we were right!</span>
<span class="c"># So what if we change this value ?</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tuplecpy</span><span class="p">(</span><span class="n">time_2</span><span class="o">.</span><span class="n">func_code</span><span class="o">.</span><span class="n">co_consts</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,),</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">time_2</span><span class="o">.</span><span class="n">func_code</span><span class="o">.</span><span class="n">co_consts</span> <span class="c"># tuple of constants of our code object</span>
<span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">time_2</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="mi">40</span> <span class="c"># woot! It works!</span></code></pre></figure>

<p>所以说我们可以修改函数中的常量。   那么我们能不能对<code class="highlighter-rouge">LOAD_FAST</code>也做同样的事情呢？</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">time_2</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c"># works on the modified function!</span>
<span class="mi">40</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">time_2</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="c"># call by dict</span>
<span class="mi">40</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">time_2</span><span class="o">.</span><span class="n">func_code</span><span class="o">.</span><span class="n">co_varnames</span> <span class="c"># tuple of local variables and argnames</span>
<span class="p">(</span><span class="s">'x'</span><span class="p">,)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tuplecpy</span><span class="p">(</span><span class="n">time_2</span><span class="o">.</span><span class="n">func_code</span><span class="o">.</span><span class="n">co_varnames</span><span class="p">,</span> <span class="p">(</span><span class="s">'new_arg_name'</span><span class="p">,),</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">time_2</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="c"># x is not the argument name anymore!</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="n">time_2</span><span class="p">()</span> <span class="n">got</span> <span class="n">an</span> <span class="n">unexpected</span> <span class="n">keyword</span> <span class="n">argument</span> <span class="s">'x'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">time_2</span><span class="p">(</span><span class="n">new_arg_name</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="mi">40</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">time_2</span><span class="p">)</span> <span class="c"># see the function changes:</span>
          <span class="mi">0</span> <span class="n">LOAD_CONST</span>               <span class="mi">1</span> <span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c"># const changed</span>
          <span class="mi">3</span> <span class="n">LOAD_FAST</span>                <span class="mi">0</span> <span class="p">(</span><span class="n">new_arg_name</span><span class="p">)</span> <span class="c"># arg name changed</span>
          <span class="mi">6</span> <span class="n">BINARY_MULTIPLY</span>
          <span class="mi">7</span> <span class="n">RETURN_VALUE</span></code></pre></figure>

<p>所以，是的，我们可以很好地修改函数的表现！</p>

<p>这是最后一个例子我觉得非常有趣：</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">nop</span><span class="p">():</span> <span class="k">pass</span>  <span class="c"># the function that does nothing</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">nop</span><span class="p">)</span>
         <span class="mi">0</span> <span class="n">LOAD_CONST</span>               <span class="mi">0</span> <span class="p">(</span><span class="bp">None</span><span class="p">)</span>
         <span class="mi">3</span> <span class="n">RETURN_VALUE</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">nop</span><span class="o">.</span><span class="n">func_code</span><span class="o">.</span><span class="n">func_consts</span>
<span class="p">(</span><span class="bp">None</span><span class="p">,)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tuplecpy</span><span class="p">(</span><span class="n">nop</span><span class="o">.</span><span class="n">func_code</span><span class="o">.</span><span class="n">func_consts</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="p">,),</span> <span class="mi">0</span><span class="p">)</span>  <span class="c"># the function will always return the same list!</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">nop</span><span class="p">()</span>
<span class="p">[]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">nop</span><span class="p">()</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">nop</span><span class="p">)</span>
         <span class="mi">0</span> <span class="n">LOAD_CONST</span>               <span class="mi">0</span> <span class="p">([</span><span class="mi">2</span><span class="p">])</span>
         <span class="mi">3</span> <span class="n">RETURN_VALUE</span></code></pre></figure>

<h1 id="函数闭包">函数闭包</h1>

<p>最后，我们来玩一下闭包！一个函数生成另外的函数的时候就会出现闭包。<a href="http://en.wikipedia.org/wiki/Closure_%28computer_programming%29">维基的解释</a></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">gen_return_function</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
<span class="o">...</span>         <span class="k">return</span> <span class="n">x</span>  <span class="c"># in f(): x is going to be a closure</span>
<span class="o">...</span>     <span class="k">return</span> <span class="n">f</span>
<span class="o">...</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">ret_42</span> <span class="o">=</span> <span class="n">gen_return_function</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ret_42</span><span class="p">()</span>
<span class="mi">42</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">ret_42</span><span class="p">)</span>
          <span class="mi">0</span> <span class="n">LOAD_DEREF</span>               <span class="mi">0</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
          <span class="mi">3</span> <span class="n">RETURN_VALUE</span></code></pre></figure>

<p>新出现的步骤 <code class="highlighter-rouge">LOAD_DEREF</code> 是用来处理闭包的。问题是：闭包保存在哪里？  答案很简单：闭包就保存在<code class="highlighter-rouge">ret_42.func_closure</code>里面。为什么不是在对象编码中？因为这样可以允许所有被生成的函数共享同样的对象代码和不同的闭包！</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">ret_23</span> <span class="o">=</span> <span class="n">gen_return_function</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ret_42</span> <span class="o">=</span> <span class="n">gen_return_function</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ret_42</span><span class="o">.</span><span class="n">func_code</span> <span class="ow">is</span> <span class="n">ret_23</span><span class="o">.</span><span class="n">func_code</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ret_42</span><span class="o">.</span><span class="n">func_closure</span>
<span class="p">(</span><span class="o">&lt;</span><span class="n">cell</span> <span class="n">at</span> <span class="mh">0xa54398</span><span class="p">:</span> <span class="nb">int</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x95d748</span><span class="o">&gt;</span><span class="p">,)</span> <span class="c"># closures are always inside a cell object</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ret_42</span><span class="o">.</span><span class="n">func_closure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cell_contents</span>
<span class="mi">42</span>

<span class="c"># We are not going to rewrite the tuple but directly the contents of the cell instead.</span>
<span class="c"># We will still use tuplecpy but with an offset of (-1) because cell have no ob_size.</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1337</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tuplecpy</span><span class="p">(</span><span class="n">ret_42</span><span class="o">.</span><span class="n">func_closure</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">x</span><span class="p">,),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ret_42</span><span class="p">()</span>
<span class="mi">1337</span> <span class="c"># closure modified :)</span></code></pre></figure>

<p>就这么多！</p>

<h1 id="总结">总结</h1>

<p>我非常喜欢打乱Python（不止一次）并且我希望你也一样。我认为这是一个可以快速方便地了解Python内部结构和它们工作方式的途径。</p>

<p>最后，<code class="highlighter-rouge">ctypes</code>在处理正常工作的时候也是一个非常强大的模块，并且它提供了载入共享库和调用C函数的能力。如果你还没有用过<code class="highlighter-rouge">ctypes</code>，我强烈建议你阅读<a href="https://docs.python.org/2/library/ctypes.html">ctypes的Python文档</a>，然后试一下！</p>

<p>【译文完】</p>

</div><div class="comment-area">
   <div id="disqus_thread"></div>
   <script type="text/javascript">
       /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
       var disqus_shortname = 'heheblog'; // required: replace example with your forum shortname
       /* * * DON'T EDIT BELOW THIS LINE * * */
       (function() {
           var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
           dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
           (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
       })();
   </script>
   <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
   <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
   
</div></div></div></div></div><div class="footer"><div class="inner-footer"><p>&copy; Copyright 2014 by Yuwei Ba</p></div></div></body></html>
